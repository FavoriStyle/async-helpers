function wait(e){return new Promise(t=>setTimeout(t,e))}export const Awaiter=(()=>{const e=Symbol(),t=Object.getOwnPropertyNames(Promise.prototype).filter(e=>"constructor"!==e&&"function"==typeof Promise.prototype[e]);function r(){if(!new.target)throw new Error("Awaiter is a class so must be constructed with `new`");let r,n;const s=new Promise((e,t)=>{r=e,n=t}),o={resolve:r,reject:n};t.forEach(e=>o[e]=s[e].bind(s)),Object.defineProperty(this,e,{configurable:!1,enumerable:!1,writable:!1,value:o})}const n={};return["resolve","reject",...t].forEach(t=>n[t]=function(...r){return this[e][t](...r)}),r.prototype=Object.assign(Object.create(Promise.prototype),n),r})();const asyncFunctionIntervalIdentifier=Symbol();export class Interval extends Awaiter{constructor(e,t=0,...r){super();const n=e[asyncFunctionIntervalIdentifier]||((...t)=>{e(...t)});this._handler=!0,(async()=>{for(;this._handler;)await wait(t),await n(...r)})().catch(this.reject.bind(this))}isWorking(){return this._handler}_clear(){this._handler=!1}resolve(){return this._clear(),super.resolve()}reject(){return this._clear(),super.reject()}};class AsyncInterval extends Interval{constructor(e,t=0,...r){super({[asyncFunctionIntervalIdentifier]:e},t,...r)}}Interval.Async=AsyncInterval;